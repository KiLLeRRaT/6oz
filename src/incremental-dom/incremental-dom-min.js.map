{"version":3,"file":"incremental-dom-min.js","sources":["src/util.js","src/node_data.js","src/types.js","src/nodes.js","src/dom_util.js","src/core.js","src/global.js","src/symbols.js","src/attributes.js","src/virtual_elements.js"],"sourcesContent":["/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * A cached reference to the hasOwnProperty function.\n */\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\n\n\n/**\n * A constructor function that will create blank objects.\n * @constructor\n */\nfunction Blank() {}\n\nBlank.prototype = Object.create(null);\n\n\n/**\n * Used to prevent property collisions between our \"map\" and its prototype.\n * @param {!Object<string, *>} map The map to check.\n * @param {string} property The property to check.\n * @return {boolean} Whether map has property.\n */\nconst has = function(map, property) {\n  return hasOwnProperty.call(map, property);\n};\n\n\n/**\n * Creates an map object without a prototype.\n * @return {!Object}\n */\nconst createMap = function() {\n  return new Blank();\n};\n\n\n/**\n * Truncates an array, removing items up until length.\n * @param {!Array<*>} arr The array to truncate.\n * @param {number} length The new length of the array.\n */\nconst truncateArray = function(arr, length) {\n  while (arr.length > length) {\n    arr.pop();\n  }\n};\n\n\n/** */\nexport {\n  createMap,\n  has,\n  truncateArray\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types.js';\nimport { createMap } from './util.js';\n\n\n/**\n * Keeps track of information needed to perform diffs for a given DOM node.\n * @param {NameOrCtorDef} nameOrCtor\n * @param {?string=} key\n * @param {*=} typeId\n * @constructor\n */\nfunction NodeData(nameOrCtor, key, typeId) {\n  /**\n   * An array of attribute name/value pairs, used for quickly diffing the\n   * incomming attributes to see if the DOM node's attributes need to be\n   * updated.\n   * @const {Array<*>}\n   */\n  this.attrsArr = [];\n\n  /**\n   * Whether or not the statics have been applied for the node yet.\n   * {boolean}\n   */\n  this.staticsApplied = false;\n\n  /**\n   * The key used to identify this node, used to preserve DOM nodes when they\n   * move within their parent.\n   * @type {?string|undefined}\n   */\n  this.key = key;\n\n  /**\n   * Keeps track of children within this node by their key.\n   * {!Object<string, !Element>}\n   */\n  this.keyMap = createMap();\n\n  /**\n   * Whether or the associated node is, or contains, a focused Element.\n   * @type {boolean}\n   */\n  this.focused = false;\n\n  /**\n   * The nodeName or contructor for the Node.\n   * @const {NameOrCtorDef}\n   */\n  this.nameOrCtor = nameOrCtor;\n\n  /**\n   * @type {?string}\n   */\n  this.text = null;\n\n  /**\n   * @const\n   */\n  this.typeId = typeId;\n}\n\n\n/**\n * Initializes a NodeData object for a Node.\n *\n * @param {Node} node The node to initialize data for.\n * @param {NameOrCtorDef} nameOrCtor The nodeName or constructor for the Node.\n * @param {?string=} key The key that identifies the node.\n * @param {*=} typeId The type identifier for the Node.\n * @return {!NodeData} The newly initialized data object\n */\nconst initData = function(node, nameOrCtor, key, typeId) {\n  const data = new NodeData(nameOrCtor, key, typeId);\n  node['__incrementalDOMData'] = data;\n  return data;\n};\n\n\n/**\n * Retrieves the NodeData object for a Node, creating it if necessary.\n *\n * @param {?Node} node The Node to retrieve the data for.\n * @return {!NodeData} The NodeData for this Node.\n */\nconst getData = function(node) {\n  importNode(node);\n  return node['__incrementalDOMData'];\n};\n\n\n/**\n * Imports node and its subtree, initializing caches.\n *\n * @param {?Node} node The Node to import.\n */\nconst importNode = function(node) {\n  if (node['__incrementalDOMData']) {\n    return;\n  }\n\n  const isElement = node.nodeType === 1;\n  const nodeName = isElement ? node.localName : node.nodeName;\n  const key = isElement ? node.getAttribute('key') : null;\n  const typeId = node['typeId'];\n  const data = initData(node, nodeName, key, typeId);\n\n  if (key) {\n    getData(node.parentNode).keyMap[key] = node;\n  }\n\n  if (isElement) {\n    const attributes = node.attributes;\n    const attrsArr = data.attrsArr;\n\n    for (let i = 0; i < attributes.length; i += 1) {\n      const attr = attributes[i];\n      const name = attr.name;\n      const value = attr.value;\n\n      attrsArr.push(name);\n      attrsArr.push(value);\n    }\n  }\n\n  for (let child = node.firstChild; child; child = child.nextSibling) {\n    importNode(child);\n  }\n};\n\n\n/** */\nexport {\n  getData,\n  initData,\n  importNode\n};\n","/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/** @typedef {string|!Function} */\nlet NameOrCtorDef;\n\n\nexport {\n  NameOrCtorDef\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types.js';\nimport {\n    getData,\n    initData\n} from './node_data.js';\n\n\n/**\n * Gets the namespace to create an element (of a given tag) in.\n * @param {string} tag The tag to get the namespace for.\n * @param {?Node} parent\n * @return {?string} The namespace to create the tag in.\n */\nconst getNamespaceForTag = function(tag, parent) {\n  if (tag === 'svg') {\n    return 'http://www.w3.org/2000/svg';\n  }\n\n  if (getData(parent).nameOrCtor === 'foreignObject') {\n    return null;\n  }\n\n  return parent.namespaceURI;\n};\n\n\n/**\n * Creates an Element.\n * @param {Document} doc The document with which to create the Element.\n * @param {?Node} parent\n * @param {NameOrCtorDef} nameOrCtor The tag or constructor for the Element.\n * @param {?string=} key A key to identify the Element.\n * @param {*=} typeId The type identifier for the Element.\n * @return {!Element}\n */\nconst createElement = function(doc, parent, nameOrCtor, key, typeId) {\n  let el;\n\n  if (typeof nameOrCtor === 'function') {\n    el = new nameOrCtor();\n  } else {\n    const namespace = getNamespaceForTag(nameOrCtor, parent);\n\n    if (namespace) {\n      el = doc.createElementNS(namespace, nameOrCtor);\n    } else {\n      el = doc.createElement(nameOrCtor);\n    }\n  }\n\n  initData(el, nameOrCtor, key, typeId);\n\n  return el;\n};\n\n\n/**\n * Creates a Text Node.\n * @param {Document} doc The document with which to create the Element.\n * @return {!Text}\n */\nconst createText = function(doc) {\n  const node = doc.createTextNode('');\n  initData(node, '#text', null);\n  return node;\n};\n\n\n/** */\nexport {\n  createElement,\n  createText\n};\n","/**\n * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\n/**\n * @param {!Node} node\n * @return {boolean} True if the node the root of a document, false otherwise.\n */\nconst isDocumentRoot = function(node) {\n  return node.nodeType === 11 || node.nodeType === 9;\n};\n\n\n/**\n * @param {!Node} node The node to start at, inclusive.\n * @param {?Node} root The root ancestor to get until, exclusive.\n * @return {!Array<!Node>} The ancestry of DOM nodes.\n */\nconst getAncestry = function(node, root) {\n  const ancestry = [];\n  let cur = node;\n\n  while (cur !== root) {\n    ancestry.push(cur);\n    cur = cur.parentNode;\n  }\n\n  return ancestry;\n};\n\n\n/**\n * @return {!Node} The root node of the DOM tree that contains this node.\n * @this Node\n */\nconst getRootNode = Node.prototype.getRootNode || function() {\n  let cur = this;\n  let prev = cur;\n\n  while (cur) {\n    prev = cur;\n    cur = cur.parentNode;\n  }\n\n  return prev;\n};\n\n\n/**\n * @param {!Node} node The node to get the activeElement for.\n * @return {?Element} The activeElement in the Document or ShadowRoot\n *     corresponding to node, if present.\n */\nconst getActiveElement = function(node) {\n  const root = getRootNode.call(node);\n  return isDocumentRoot(root) ? root.activeElement : null;\n};\n\n\n/**\n * Gets the path of nodes that contain the focused node in the same document as\n * a reference node, up until the root.\n * @param {!Node} node The reference node to get the activeElement for.\n * @param {?Node} root The root to get the focused path until.\n * @return {!Array<Node>}\n */\nconst getFocusedPath = function(node, root) {\n  const activeElement = getActiveElement(node);\n\n  if (!activeElement || !node.contains(activeElement)) {\n    return [];\n  }\n\n  return getAncestry(activeElement, root);\n};\n\n\n/**\n * Like insertBefore, but instead instead of moving the desired node, instead\n * moves all the other nodes after.\n * @param {?Node} parentNode\n * @param {!Node} node\n * @param {?Node} referenceNode\n */\nconst moveBefore = function(parentNode, node, referenceNode) {\n  const insertReferenceNode = node.nextSibling;\n  let cur = referenceNode;\n\n  while (cur !== node) {\n    const next = cur.nextSibling;\n    parentNode.insertBefore(cur, insertReferenceNode);\n    cur = next;\n  }\n};\n\n\n/** */\nexport {\n  getFocusedPath,\n  moveBefore\n};\n\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types.js';\nimport {\n  createElement,\n  createText\n} from './nodes.js';\nimport { getData } from './node_data.js';\nimport {\n  assertInPatch,\n  assertNoUnclosedTags,\n  assertNotInAttributes,\n  assertVirtualAttributesClosed,\n  assertNoChildrenDeclaredYet,\n  assertPatchElementNoExtras,\n  assertPatchOuterHasParentNode,\n  setInAttributes,\n  setInSkip\n} from './assertions.js';\nimport {\n  getFocusedPath,\n  moveBefore\n} from './dom_util.js';\nimport { globalObj } from './global.js';\n\n/** @type {?Node} */\nlet currentNode = null;\n\n/** @type {?Node} */\nlet currentParent = null;\n\n/** @type {?Document} */\nlet doc = null;\n\n\n/**\n * @param {!Array<Node>} focusPath The nodes to mark.\n * @param {boolean} focused Whether or not they are focused.\n */\nconst markFocused = function(focusPath, focused) {\n  for (let i = 0; i < focusPath.length; i += 1) {\n    getData(focusPath[i]).focused = focused;\n  }\n};\n\n\n/**\n * Returns a patcher function that sets up and restores a patch context,\n * running the run function with the provided data.\n * @param {function((!Element|!DocumentFragment),!function(T),T=): R} run\n * @return {function((!Element|!DocumentFragment),!function(T),T=): R}\n * @template T, R\n */\nconst patchFactory = function(run) {\n  /**\n   * TODO(moz): These annotations won't be necessary once we switch to Closure\n   * Compiler's new type inference. Remove these once the switch is done.\n   *\n   * @param {(!Element|!DocumentFragment)} node\n   * @param {!function(T)} fn\n   * @param {T=} data\n   * @return {R} node\n   * @template T, R\n   */\n  const f = function(node, fn, data) {\n    const prevDoc = doc;\n    const prevCurrentNode = currentNode;\n    const prevCurrentParent = currentParent;\n    let previousInAttributes = false;\n    let previousInSkip = false;\n\n    doc = node.ownerDocument;\n    currentParent = node.parentNode;\n\n    if (globalObj.DEBUG) {\n      previousInAttributes = setInAttributes(false);\n      previousInSkip = setInSkip(false);\n    }\n\n    const focusPath = getFocusedPath(node, currentParent);\n    markFocused(focusPath, true);\n    const retVal = run(node, fn, data);\n    markFocused(focusPath, false);\n\n    if (globalObj.DEBUG) {\n      assertVirtualAttributesClosed();\n      setInAttributes(previousInAttributes);\n      setInSkip(previousInSkip);\n    }\n\n    doc = prevDoc;\n    currentNode = prevCurrentNode;\n    currentParent = prevCurrentParent;\n\n    return retVal;\n  };\n  return f;\n};\n\n\n/**\n * Patches the document starting at node with the provided function. This\n * function may be called during an existing patch operation.\n * @param {!Element|!DocumentFragment} node The Element or Documen to patch.\n * @param {!function(T)} fn A function containing open/close/etc. calls that\n *     describe the DOM.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {!Node} The patched node.\n * @template T\n */\nconst patchInner = patchFactory(function(node, fn, data) {\n  currentNode = node;\n\n  enterNode();\n  fn(data);\n  exitNode();\n\n  if (globalObj.DEBUG) {\n    assertNoUnclosedTags(currentNode, node);\n  }\n\n  return node;\n});\n\n\n/**\n * Patches an Element with the the provided function. Exactly one top level\n * element call should be made corresponding to `node`.\n * @param {!Element} node The Element where the patch should start.\n * @param {!function(T)} fn A function containing open/close/etc. calls that\n *     describe the DOM. This should have at most one top level element call.\n * @param {T=} data An argument passed to fn to represent DOM state.\n * @return {?Node} The node if it was updated, its replacedment or null if it\n *     was removed.\n * @template T\n */\nconst patchOuter = patchFactory(function(node, fn, data) {\n  let startNode = /** @type {!Element} */({ nextSibling: node });\n  let expectedNextNode = null;\n  let expectedPrevNode = null;\n\n  if (globalObj.DEBUG) {\n    assertPatchOuterHasParentNode(currentParent);\n    expectedNextNode = node.nextSibling;\n    expectedPrevNode = node.previousSibling;\n  }\n\n  currentNode = startNode;\n  fn(data);\n\n  if (globalObj.DEBUG) {\n    assertPatchElementNoExtras(startNode, currentNode, expectedNextNode,\n        expectedPrevNode);\n  }\n\n  if (currentParent) {\n    clearUnvisitedDOM(currentParent, getNextNode(), node.nextSibling);\n  }\n\n  return (startNode === currentNode) ? null : currentNode;\n});\n\n\n/**\n * Checks whether or not the current node matches the specified nameOrCtor and\n * key.\n *\n * @param {!Node} matchNode A node to match the data to.\n * @param {NameOrCtorDef} nameOrCtor The name or constructor to check for.\n * @param {?string=} key An optional key that identifies a node.\n * @param {*=} typeId An type identifier that avoids reuse between elements that\n *     would otherwise match.\n * @return {boolean} True if the node matches, false otherwise.\n */\nconst matches = function(matchNode, nameOrCtor, key, typeId) {\n  const data = getData(matchNode);\n\n  // Key check is done using double equals as we want to treat a null key the\n  // same as undefined. This should be okay as the only values allowed are\n  // strings, null and undefined so the == semantics are not too weird.\n  return nameOrCtor === data.nameOrCtor &&\n         typeId === data.typeId &&\n         key == data.key;\n};\n\n\n/**\n * Aligns the virtual Node definition with the actual DOM, moving the\n * corresponding DOM node to the correct location or creating it if necessary.\n * @param {NameOrCtorDef} nameOrCtor The name or constructor for the Node.\n * @param {?string=} key The key used to identify the Node..\n * @param {*=} typeId An type identifier that avoids reuse between elements that\n *     would otherwise match.\n */\nconst alignWithDOM = function(nameOrCtor, key, typeId) {\n  if (currentNode && matches(currentNode, nameOrCtor, key, typeId)) {\n    return;\n  }\n\n  const parentData = getData(currentParent);\n  const keyMap = parentData.keyMap;\n  let node;\n\n  // Check to see if the node has moved within the parent.\n  if (key) {\n    const keyNode = keyMap[key];\n    if (keyNode) {\n      if (matches(keyNode, nameOrCtor, key, typeId)) {\n        node = keyNode;\n      } else {\n        // When the keyNode gets removed later, make sure we do not remove the\n        // new node from the map.\n        getData(keyNode).key = null;\n      }\n    }\n  }\n\n  // Create the node if it doesn't exist.\n  if (!node) {\n    if (nameOrCtor === '#text') {\n      node = createText(doc);\n    } else {\n      node = createElement(doc, currentParent, nameOrCtor, key, typeId);\n    }\n\n    if (key) {\n      keyMap[key] = node;\n    }\n  }\n\n  // Re-order the node into the right position, preserving focus if either\n  // node or currentNode are focused by making sure that they are not detached\n  // from the DOM.\n  if (getData(node).focused) {\n    // Move everything else before the node.\n    moveBefore(currentParent, node, currentNode);\n  } else {\n    currentParent.insertBefore(node, currentNode);\n  }\n\n  currentNode = node;\n};\n\n\n/**\n * Clears out any unvisited Nodes in a given range.\n * @param {?Node} parentNode\n * @param {?Node} startNode The node to start clearing from, inclusive.\n * @param {?Node} endNode The node to clear until, exclusive.\n */\nconst clearUnvisitedDOM = function(parentNode, startNode, endNode) {\n  const data = getData(parentNode);\n  const keyMap = data.keyMap;\n  let child = startNode;\n\n  while (child !== endNode) {\n    const next = child.nextSibling;\n    const key = getData(child).key;\n    parentNode.removeChild(child);\n    if (key) {\n      delete keyMap[key];\n    }\n    child = next;\n  }\n};\n\n\n/**\n * Changes to the first child of the current node.\n */\nconst enterNode = function() {\n  currentParent = currentNode;\n  currentNode = null;\n};\n\n\n/**\n * @return {?Node} The next Node to be patched.\n */\nconst getNextNode = function() {\n  if (currentNode) {\n    return currentNode.nextSibling;\n  } else {\n    return currentParent.firstChild;\n  }\n};\n\n\n/**\n * Changes to the next sibling of the current node.\n */\nconst nextNode = function() {\n  currentNode = getNextNode();\n};\n\n\n/**\n * Changes to the parent of the current node, removing any unvisited children.\n */\nconst exitNode = function() {\n  clearUnvisitedDOM(currentParent, getNextNode(), null);\n\n  currentNode = currentParent;\n  currentParent = currentParent.parentNode;\n};\n\n\n/**\n * Makes sure that the current node is an Element with a matching nameOrCtor and\n * key.\n *\n * @param {NameOrCtorDef} nameOrCtor The tag or constructor for the Element.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {*=} typeId An type identifier that avoids reuse between elements that\n *     would otherwise match.\n * @return {!Element} The corresponding Element.\n */\nconst open = function(nameOrCtor, key, typeId) {\n  nextNode();\n  alignWithDOM(nameOrCtor, key, typeId);\n  enterNode();\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * Closes the currently open Element, removing any unvisited children if\n * necessary.\n *\n * @return {!Element} The corresponding Element.\n */\nconst close = function() {\n  if (globalObj.DEBUG) {\n    setInSkip(false);\n  }\n\n  exitNode();\n  return /** @type {!Element} */(currentNode);\n};\n\n\n/**\n * Makes sure the current node is a Text node and creates a Text node if it is\n * not.\n *\n * @return {!Text} The corresponding Text Node.\n */\nconst text = function() {\n  nextNode();\n  alignWithDOM('#text', null);\n  return /** @type {!Text} */(currentNode);\n};\n\n\n/**\n * Gets the current Element being patched.\n * @return {!Element}\n */\nconst currentElement = function() {\n  if (globalObj.DEBUG) {\n    assertInPatch('currentElement', doc);\n    assertNotInAttributes('currentElement');\n  }\n  return /** @type {!Element} */(currentParent);\n};\n\n\n/**\n * @return {Node} The Node that will be evaluated for the next instruction.\n */\nconst currentPointer = function() {\n  if (globalObj.DEBUG) {\n    assertInPatch('currentPointer', doc);\n    assertNotInAttributes('currentPointer');\n  }\n  return getNextNode();\n};\n\n\n/**\n * Skips the children in a subtree, allowing an Element to be closed without\n * clearing out the children.\n */\nconst skip = function() {\n  if (globalObj.DEBUG) {\n    assertNoChildrenDeclaredYet('skip', currentNode);\n    setInSkip(true);\n  }\n  currentNode = currentParent.lastChild;\n};\n\n\n/**\n * Skips the next Node to be patched, moving the pointer forward to the next\n * sibling of the current pointer.\n */\nconst skipNode = nextNode;\n\n\n/** */\nexport {\n  text,\n  patchInner,\n  patchOuter,\n  open,\n  close,\n  currentElement,\n  currentPointer,\n  skip,\n  skipNode\n};\n","/**\n * Copyright 2017 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst globalObj = typeof self !== 'undefined' ? self :\n    typeof window !== 'undefined' ?  window :\n    typeof global !== 'undefined' ?  global :\n    {};\n\nexport {\n  globalObj\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** @const */\nconst symbols = {\n  default: '__default'\n};\n\n/** */\nexport {\n  symbols\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { symbols } from './symbols.js';\nimport {\n  createMap,\n  has\n} from './util.js';\n\n\n/**\n * @param {string} name\n * @return {string|undefined} The namespace to use for the attribute.\n */\nconst getNamespace = function(name) {\n  if (name.lastIndexOf('xml:', 0) === 0) {\n    return 'http://www.w3.org/XML/1998/namespace';\n  }\n\n  if (name.lastIndexOf('xlink:', 0) === 0) {\n    return 'http://www.w3.org/1999/xlink';\n  }\n};\n\n\n/**\n * Applies an attribute or property to a given Element. If the value is null\n * or undefined, it is removed from the Element. Otherwise, the value is set\n * as an attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {?(boolean|number|string)=} value The attribute's value.\n */\nconst applyAttr = function(el, name, value) {\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    const attrNS = getNamespace(name);\n    if (attrNS) {\n      el.setAttributeNS(attrNS, name, value);\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n};\n\n/**\n * Applies a property to a given Element.\n * @param {!Element} el\n * @param {string} name The property's name.\n * @param {*} value The property's value.\n */\nconst applyProp = function(el, name, value) {\n  el[name] = value;\n};\n\n\n/**\n * Applies a value to a style declaration. Supports CSS custom properties by\n * setting properties containing a dash using CSSStyleDeclaration.setProperty.\n * @param {CSSStyleDeclaration} style\n * @param {string} prop\n * @param {string} value\n */\nconst setStyleValue = function(style, prop, value) {\n  if (prop.indexOf('-') >= 0) {\n    style.setProperty(prop, value);\n  } else {\n    style[prop] = value;\n  }\n};\n\n\n/**\n * Applies a style to an Element. No vendor prefix expansion is done for\n * property names/values.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} style The style to set. Either a string of css or an object\n *     containing property-value pairs.\n */\nconst applyStyle = function(el, name, style) {\n  if (typeof style === 'string') {\n    el.style.cssText = style;\n  } else {\n    el.style.cssText = '';\n    const elStyle = el.style;\n    const obj = /** @type {!Object<string,string>} */(style);\n\n    for (const prop in obj) {\n      if (has(obj, prop)) {\n        setStyleValue(elStyle, prop, obj[prop]);\n      }\n    }\n  }\n};\n\n\n/**\n * Updates a single attribute on an Element.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value. If the value is an object or\n *     function it is set on the Element, otherwise, it is set as an HTML\n *     attribute.\n */\nconst applyAttributeTyped = function(el, name, value) {\n  const type = typeof value;\n\n  if (type === 'object' || type === 'function') {\n    applyProp(el, name, value);\n  } else {\n    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));\n  }\n};\n\n\n/**\n * Calls the appropriate attribute mutator for this attribute.\n * @param {!Element} el\n * @param {string} name The attribute's name.\n * @param {*} value The attribute's value.\n */\nconst updateAttribute = function(el, name, value) {\n  const mutator = attributes[name] || attributes[symbols.default];\n  mutator(el, name, value);\n};\n\n\n/**\n * A publicly mutable object to provide custom mutators for attributes.\n * @const {!Object<string, function(!Element, string, *)>}\n */\nconst attributes = createMap();\n\n// Special generic mutator that's called for any attribute that does not\n// have a specific mutator.\nattributes[symbols.default] = applyAttributeTyped;\n\nattributes['style'] = applyStyle;\n//PM 20171225 - FIX FOR SETTINGS PROPERTIES ON ELEMENT\nattributes.checked = attributes.className = attributes.disabled = attributes.value = applyProp;\n\n\n/** */\nexport {\n  updateAttribute,\n  applyProp,\n  applyAttr,\n  attributes\n};\n","/**\n * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS-IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NameOrCtorDef } from './types.js';\nimport {\n  open,\n  close,\n  text as coreText\n} from './core.js';\nimport { updateAttribute } from './attributes.js';\nimport { getData } from './node_data.js';\nimport {\n  assertNotInAttributes,\n  assertNotInSkip,\n  assertInAttributes,\n  assertCloseMatchesOpenTag,\n  setInAttributes\n} from './assertions.js';\nimport {\n  createMap,\n  truncateArray\n} from './util.js';\nimport { globalObj } from './global.js';\n\n\n/**\n * The offset in the virtual element declaration where the attributes are\n * specified.\n * @const\n */\nconst ATTRIBUTES_OFFSET = 3;\n\n\n/**\n * Builds an array of arguments for use with elementOpenStart, attr and\n * elementOpenEnd.\n * @const {!Array<*>}\n */\nconst argsBuilder = [];\n\n\n/**\n * Used to keep track of the previous values when a 2-way diff is necessary.\n * This object is reused.\n * @const {Object<*>}\n */\nconst prevAttrsMap = createMap();\n\n\n/**\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpen = function(nameOrCtor, key, statics, var_args) {\n  if (globalObj.DEBUG) {\n    assertNotInAttributes('elementOpen');\n    assertNotInSkip('elementOpen');\n  }\n\n  const node = open(nameOrCtor, key);\n  const data = getData(node);\n\n  if (!data.staticsApplied) {\n    if (statics) {\n      for (let i = 0; i < statics.length; i += 2) {\n        const name = /** @type {string} */(statics[i]);\n        const value = statics[i + 1];\n        updateAttribute(node, name, value);\n      }\n    }\n    // Down the road, we may want to keep track of the statics array to use it\n    // as an additional signal about whether a node matches or not. For now,\n    // just use a marker so that we do not reapply statics.\n    data.staticsApplied = true;\n  }\n\n  /*\n   * Checks to see if one or more attributes have changed for a given Element.\n   * When no attributes have changed, this is much faster than checking each\n   * individual argument. When attributes have changed, the overhead of this is\n   * minimal.\n   */\n  const attrsArr = data.attrsArr;\n  const isNew = !attrsArr.length;\n  let i = ATTRIBUTES_OFFSET;\n  let j = 0;\n\n  for (; i < arguments.length; i += 2, j += 2) {\n    const name = arguments[i];\n    if (isNew) {\n      attrsArr[j] = name;\n    } else if (attrsArr[j] !== name) {\n      break;\n    }\n\n    const value = arguments[i + 1];\n    if (isNew || attrsArr[j + 1] !== value) {\n      attrsArr[j + 1] = value;\n      updateAttribute(node, name, value);\n    }\n  }\n\n  /*\n   * Items did not line up exactly as before, need to make sure old items are\n   * removed. This can happen if using conditional logic when declaring\n   * attrs through the elementOpenStart flow or if one element is reused in\n   * the place of another.\n   */\n  if (i < arguments.length || j < attrsArr.length) {\n    const attrsStart = j;\n\n    for (; j < attrsArr.length; j += 2) {\n      prevAttrsMap[attrsArr[j]] = attrsArr[j + 1];\n    }\n\n    for (j = attrsStart; i < arguments.length; i += 2, j += 2) {\n      const name = arguments[i];\n      const value = arguments[i + 1];\n\n      if (prevAttrsMap[name] !== value) {\n        updateAttribute(node, name, value);\n      }\n\n      attrsArr[j] = name;\n      attrsArr[j + 1] = value;\n\n      delete prevAttrsMap[name];\n    }\n\n    truncateArray(attrsArr, j);\n\n    /*\n     * At this point, only have attributes that were present before, but have\n     * been removed.\n     */\n    for (const name in prevAttrsMap) {\n      updateAttribute(node, name, undefined);\n      delete prevAttrsMap[name];\n    }\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document. This\n * corresponds to an opening tag and a elementClose tag is required. This is\n * like elementOpen, but the attributes are defined using the attr function\n * rather than being passed as arguments. Must be folllowed by 0 or more calls\n * to attr, then a call to elementOpenEnd.\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n */\nconst elementOpenStart = function(nameOrCtor, key, statics) {\n  if (globalObj.DEBUG) {\n    assertNotInAttributes('elementOpenStart');\n    setInAttributes(true);\n  }\n\n  argsBuilder[0] = nameOrCtor;\n  argsBuilder[1] = key;\n  argsBuilder[2] = statics;\n};\n\n\n/***\n * Defines a virtual attribute at this point of the DOM. This is only valid\n * when called between elementOpenStart and elementOpenEnd.\n *\n * @param {string} name\n * @param {*} value\n */\nconst attr = function(name, value) {\n  if (globalObj.DEBUG) {\n    assertInAttributes('attr');\n  }\n\n  argsBuilder.push(name);\n  argsBuilder.push(value);\n};\n\n\n/**\n * Closes an open tag started with elementOpenStart.\n * @return {!Element} The corresponding Element.\n */\nconst elementOpenEnd = function() {\n  if (globalObj.DEBUG) {\n    assertInAttributes('elementOpenEnd');\n    setInAttributes(false);\n  }\n\n  const node = elementOpen.apply(null, argsBuilder);\n  truncateArray(argsBuilder, 0);\n  return node;\n};\n\n\n/**\n * Closes an open virtual Element.\n *\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @return {!Element} The corresponding Element.\n */\nconst elementClose = function(nameOrCtor) {\n  if (globalObj.DEBUG) {\n    assertNotInAttributes('elementClose');\n  }\n\n  const node = close();\n\n  if (globalObj.DEBUG) {\n    assertCloseMatchesOpenTag(getData(node).nameOrCtor, nameOrCtor);\n  }\n\n  return node;\n};\n\n\n/**\n * Declares a virtual Element at the current location in the document that has\n * no children.\n * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.\n * @param {?string=} key The key used to identify this element. This can be an\n *     empty string, but performance may be better if a unique value is used\n *     when iterating over an array of items.\n * @param {?Array<*>=} statics An array of attribute name/value pairs of the\n *     static attributes for the Element. These will only be set once when the\n *     Element is created.\n * @param {...*} var_args Attribute name/value pairs of the dynamic attributes\n *     for the Element.\n * @return {!Element} The corresponding Element.\n */\nconst elementVoid = function(nameOrCtor, key, statics, var_args) {\n  elementOpen.apply(null, arguments);\n  return elementClose(nameOrCtor);\n};\n\n\n/**\n * Declares a virtual Text at this point in the document.\n *\n * @param {string|number|boolean} value The value of the Text.\n * @param {...(function((string|number|boolean)):string)} var_args\n *     Functions to format the value which are called only when the value has\n *     changed.\n * @return {!Text} The corresponding text node.\n */\nconst text = function(value, var_args) {\n  if (globalObj.DEBUG) {\n    assertNotInAttributes('text');\n    assertNotInSkip('text');\n  }\n\n  const node = coreText();\n  const data = getData(node);\n\n  if (data.text !== value) {\n    data.text = /** @type {string} */(value);\n\n    let formatted = value;\n    for (let i = 1; i < arguments.length; i += 1) {\n      /*\n       * Call the formatter function directly to prevent leaking arguments.\n       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574\n       */\n      const fn = arguments[i];\n      formatted = fn(formatted);\n    }\n\n    node.data = formatted;\n  }\n\n  return node;\n};\n\n\n/** */\nexport {\n  elementOpenStart,\n  elementOpenEnd,\n  elementOpen,\n  elementVoid,\n  elementClose,\n  text,\n  attr\n};\n"],"names":["Blank","NodeData","nameOrCtor","key","typeId","attrsArr","staticsApplied","keyMap","createMap","focused","text","hasOwnProperty","Object","prototype","create","has","map","property","call","truncateArray","arr","length","pop","initData","node","data","getData","importNode","isElement","nodeType","nodeName","localName","getAttribute","parentNode","attributes","i","attr","name","value","push","child","firstChild","nextSibling","getNamespaceForTag","tag","parent","namespaceURI","createElement","doc","el","namespace","createElementNS","createText","createTextNode","isDocumentRoot","getAncestry","root","ancestry","cur","getRootNode","Node","this","prev","getActiveElement","activeElement","getFocusedPath","contains","moveBefore","referenceNode","insertReferenceNode","next","insertBefore","currentNode","self","window","global","currentParent","markFocused","focusPath","patchFactory","run","f","fn","prevDoc","prevCurrentNode","prevCurrentParent","ownerDocument","retVal","patchInner","patchOuter","startNode","getNextNode","matches","matchNode","alignWithDOM","parentData","keyNode","clearUnvisitedDOM","endNode","removeChild","enterNode","nextNode","exitNode","open","close","currentElement","currentPointer","skip","lastChild","skipNode","symbols","getNamespace","lastIndexOf","applyAttr","removeAttribute","attrNS","setAttributeNS","setAttribute","applyProp","setStyleValue","style","prop","indexOf","setProperty","applyStyle","cssText","elStyle","obj","applyAttributeTyped","type","updateAttribute","mutator","default","checked","className","disabled","ATTRIBUTES_OFFSET","argsBuilder","prevAttrsMap","elementOpen","statics","isNew","j","arguments","attrsStart","undefined","elementOpenStart","elementOpenEnd","apply","elementClose","elementVoid","coreText","formatted"],"mappings":"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","sourceRoot":"/source/"}